## Chapter 11

### Proxy Pattern

한 객체가 다른 객체를 대신해서 특정한 작업을 수행하는 패턴

- 객체의 접근을 제어하고, 객체의 동작을 보호하고, 객체에 대한 부가적인 기능을 제공하는 데 사용

#### 구성 요소

1. 실제 객체(Real Subject) : 프록시 객체가 대신할 실제 객체

- 프록시 객체와 같은 인터페이스를 가지고 있다.

2. 프록시 객체(Proxy) : 실제 객체를 대신하여 동작하는 객체

- 실제 객체와 같은 인터페이스를 가지고 있다.
- 실제 객체에 대한 접근을 제어하고, 객체의 동작을 보호하며, 부가적인 기능을 제공한다.

3. 클라이언트(Client) : 프록시 객체를 사용하여 실제 객체에 접근하는 객체

- 프록시 객체를 사용하여 실제 객체에 접근하고, 프록시 객체가 제공하는 기능을 사용할 수 있다.

#### 사용 예시

1. 객체에 대한 접근을 제어하고, 객체의 동작을 보호해야 할 때

- 예로 파일 시스템에 접근할 때, 프록시 객체가 파일 시스템에 대한 접근을 제어하고, 파일 시스템을 보호할 수 있다.

2. 객체에 부가적인 기능을 제공해야 할 때

- 실제 객체에 부가적인 기능을 제공할 수 있다.
- 이미지 파일을 로딩할 때, 프록시 객체가 이미지 파일의 크기를 알아내거나, 이미지 파일을 캐싱하는 등의 부가적인 기능을 제공할 수 있다.

3. 객체를 생성하는 데 비용이 많이 들거나, 객체를 사용할 때마다 생성해야 할 때

- 데이터베이스 연결을 생성할 때, 프록시 객체가 데이터베이스 연결을 생성하고, 클라이언트는 프록시 객체를 사용하여 데이터베이스에 접근 할 수 있다.

#### 제공하는 기능

1. 접근 제어 : 객체의 속성에 대한 접근을 제한하거나, 객체에 접근할 때 로깅을 기록할 수 있다.
2. 부가적인 기능 제공 : 객체의 속성에 접근할 때마다 속성 값을 대문자로 변환하는 기능을 추가 할 수 있다.

#### 자바스크립트에서 구현하는 방법

```js
// ES6에 도입된 Proxy 객체
const proxy = new Proxy(target, handler);
```

- target : 대상 객체
- handler : 프록시 객체의 동작을 정의하는 핸들러 객체

```js
const target = { name: 'John', age: 30 };
const handler = {
  get: function (target, prop, receiver) {
    console.log(`Getting ${prop} property`);
    return Reflect.get(target, prop, receiver);
  },
  set: function (target, prop, value, receiver) {
    console.log(`Setting ${prop} property to ${value}`);
    return Reflect.set(target, prop, value, receiver);
  },
};
const proxy = new Proxy(target, handler);
```

- `proxy`를 통해 `target` 객체에 접근할 수 있다.
  - `proxy.name`을 실행하면, 프록시 객체의 `get` 메소드가 호출되고, `target.name` 속성 값이 반환 된다.
  - `proxy.age = 35` 를 실행하면, `set` 메서드를 호출하고 `target.age` 속성 값이 업데이트 된다.

### 장점과 단점

#### 장점

1. 접근제어 : 실제 객체에 대한 접근을 제어한다.

- 보안과 안정성을 유지할 수 있다.

2. 유연성 : 실제 객체에 대한 부가적인 기능을 제공할 수 있다.

- 프록시 객체와 실제 객체를 분리하여 각각의 역할을 수행할 수 있다.

3. 성능 개선 : 객체의 생성 및 초기화를 지연시킬 수 있다.

#### 단점

1. 복잡성 : 객체 지향 디자인 패턴 중 하나로, 복잡한 구현이 필요할 수 있다.
2. 코드 중복 : 실제 객체와 같은 인터페이스를 가지고 있기 때문에, 코드 중복이 발생할 수 있다.
3. 객체 생성 시점의 제약 : 실제 객체를 대신하기 때문에, 실제 객체가 생성되기 전에는 사용할 수 없다.

### 실사용 적용 예제

1. 원격 프록시

- 원격 서버의 객체에 접근할 때 사용된다.
- 클라이언트가 원격 서버의 객체에 직접 접근하는 대신, 프록시 객체를 통해 접근하게 된다.
- 이를 통해 네트워크 대역폭을 줄이고, 보안을 강화할 수 있다.

2. 가상 프록시

- 객체 생성 및 초기화를 지연시키는데 사용된다.
- 객체가 생성될 때까지 프록시 객체를 사용하다가, 객체가 생성되면 실제 객체로 대체된다.

3. 보호 프록시

- 객체에 대한 접근을 제한하는데 사용된다.
- 파일 시스템에서 파일을 읽거나 쓰는 작업을 할 때, 프록시 객체를 사용하여 파일에 대한 접근을 제한할 수 있다.

4. 캐시 프록시

- 객체에 대한 요청을 캐싱하여, 이전에 사용된 객체를 재사용하는데 사용된다.
- 객체의 생성 및 초기화 시간을 줄이고, 성능을 개선할 수 있다.

#### 예제1

프록시 객체를 사용하여 실제 객체에 접근할 때마다 로깅을 수행하도록 구현

```js
// 실제 객체
const person = {
  name: 'John',
  age: 30,
  gender: 'male',
};

// 프록시 객체
const personProxy = new Proxy(person, {
  // get 함수를 사용하여 객체에 접근할 때마다 로깅을 수행
  get(target, property) {
    console.log(`Accessing ${property}`);
    return target[property];
  },
  // set 함수를 사용하여 객체에 값을 할당할 때마다 로깅을 수행
  set(target, property, value) {
    console.log(`Setting ${property} to ${value}`);
    target[property] = value;
  },
});

// 프록시 객체를 통해 실제 객체에 접근
console.log(personProxy.name); // "Accessing name", "John"
personProxy.age = 35; // "Setting age to 35"

// 실제 객체의 값도 변경됨
console.log(person.age); // 35
```

이를 통해 실제 객체의 속성을 읽거나 쓰면 해당 로깅이 출력된다.

#### 예제 2

자바스크립트에서 프록시 패턴을 구현하는 방법

```js
// 실제 객체
const person = {
  name: 'John',
  age: 30,
};

// 프록시 객체
const personProxy = new Proxy(person, {
  // get 메소드를 이용해 프록시 객체의 프로퍼티에 접근했을 때,
  // 실제 객체의 프로퍼티에 접근하는 대신,
  // 프록시 객체에서 해당 프로퍼티의 값을 반환합니다.
  get: function (target, prop) {
    // 프로퍼티가 'age'인 경우에만 값을 반환합니다.
    if (prop === 'age') {
      return target[prop];
    } else {
      return 'Access denied';
    }
  },
});

// 프록시 객체의 'name' 프로퍼티에 접근합니다.
console.log(personProxy.name); // "Access denied"

// 프록시 객체의 'age' 프로퍼티에 접근합니다.
console.log(personProxy.age); // 30
```

`person`을 대신하여 프록시 객체 `personProxy`를 만들어 사용
`personProxy`는 `Proxy` 객체를 이용하여 만들어졌으며, `get`메소드를 사용하여 프로퍼티에 접근할 때마다 동작을 수행

`age` 프로퍼티에만 접근을 허용하도록 구현되었기에, `name` 프로퍼티에 접근하면 `Access denied` 라는 메시지가 출력된다.

`age` 프로퍼티에 접근하면 실제 객체인 `person`의 `age` 프로퍼티 값을 반환한다.

#### 프록시패턴과 옵저버패턴

###### 프록시 패턴

- 객체의 인터페이스를 제어하거나, 객체에 대한 접근을 제한하거나, 객체의 생성 및 초기화를 지연시키는 등의 기능을 제공
- 객체에 대한 접근을 제한할 때는 보호 프록시, 객체의 생성 및 초기화를 지연시킬 때는 가상 프록시, 객체의 인터페이스를 제어할 때는 원격 프록시 등 다양한 유형의 프록시 패턴이 있다.

###### 옵저버 패턴

- 객체 사이의 상호작용을 설계하는데 사용된다.
- 객체가 발생시키는 이벤트를 다른 객체들이 구독하고, 이벤트가 발생하면 구독한 객체들에게 알림을 보내는 방식으로 동작
- 버튼을 클릭할 때 클릭 이벤트를 발생시키고, 클릭 이벤트를 구독한 객체들에게 알림을 보내는 방식으로 동작
